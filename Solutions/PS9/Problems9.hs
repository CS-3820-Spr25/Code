module Problems9 (module Problems9) where

{-------------------------------------------------------------------------------

CS:3820 Spring 2025 Problem Set 5
=================================

This problem continues the development of the syntax and semantics
of regular expressions we saw earlier this semester.  For syntax,
we're going to consider a generalized form of regular expression.
For semantics, we're going to find a way to compute the "remainder"
after a regular expression accepts the beginning of a string.

-------------------------------------------------------------------------------}

{-------------------------------------------------------------------------------

Generalized regular expressions
-------------------------------

The grammar of generalized regular expressions is very similar the one we
presented in class.  There are a few differences, however:

 - We don't include an option for "any character"---instead, that has to be done
   with the `Chars` constructor
 - We include both *and* and *or* constructions, and a negation.
 - We only include the star operator---you should be able to see how the option
   (`?`) and `+` operators can be defined in terms of what we have here.


-------------------------------------------------------------------------------}

data GRegex = 
    None                      -- Matches *no* strings, no matter their content
  | Empty                     -- Matches only the empty string
  | Chars [Char]              -- Matches any character from the list
  | GRegex :\/: GRegex        -- "or"---matches strings that match either the left or right hand argument
  | GRegex :/\: GRegex        -- "and"---matches strings that match both the left and right hand arguments
  | Not GRegex                -- matches strings that *don't* match its arguments
  | Star GRegex               -- repetition---matches strings that match 0 or more instances of its argument
  | GRegex :<>: GRegex        -- sequencing---matches strings that match its left hand, then its right hand argument

  deriving (Show)
  
--------------------------------------------------------------------------------
-- Problem 1-3: `singleChars`
--
-- The `Chars` constructor is convenient for capturing classes of characters,
-- but it's not necessary.  Write a function that transforms an arbitrary
-- regular expression into one in which the `Chars` constructor is only ever
-- applied to a *single* character.  To be clearer, here is the constraint your
-- output regular expression must match:
--
-- This will be graded as three problems:
--   1.  None, Empty, and Chars
--   2. (:/\:), (:\/:), and Not
--   3. (:<>:) and Star
-- But we can't really test either 2 or 3 without testing 1, so if your
-- implementation of 1 is wrong you won't have any passing tests for 2 or 3
-- either.

singleCharsOnly :: GRegex -> Bool
singleCharsOnly None       = True
singleCharsOnly Empty      = True
singleCharsOnly (Chars cs) = length cs == 1
singleCharsOnly (r :\/: s) = singleCharsOnly r && singleCharsOnly s
singleCharsOnly (r :/\: s) = singleCharsOnly r && singleCharsOnly s
singleCharsOnly (Not r)    = singleCharsOnly r
singleCharsOnly (Star r)   = singleCharsOnly r
singleCharsOnly (r :<>: s) = singleCharsOnly r && singleCharsOnly s

-- Your task is to write a function that makes regular expressions pass the
-- above test:

singleChars :: GRegex -> GRegex
singleChars None       = None
singleChars Empty      = Empty
singleChars (Chars cs) = foldr (:\/:) None (map (Chars . (:[])) cs)
singleChars (r :\/: s) = singleChars r :\/: singleChars s
singleChars (r :/\: s) = singleChars r :/\: singleChars s
singleChars (Not r)    = Not (singleChars r)
singleChars (Star r)   = Star (singleChars r)
singleChars (r :<>: s) = singleChars r :<>: singleChars s

--------------------------------------------------------------------------------
-- Problems 4-6: hasEmpty
--
-- Your next task is to write a function `hasEmpty` which determines whether a
-- given regular expression can accept the empty string.  That is to say,
-- `hasEmpty r` should return `True` if the empty string is among the strings
-- generated by `r`.
--
-- Some cases of this function are more obvious: For example, the `Empty` regex
-- accepts the empty string, whereas the `None` or `Chars cs` regexes do not
-- (regardless of your choice of `cs`).  The interest arises in the treatment of
-- the combinators; for example, when does the regex `r :\/: s` accept the empty
-- string?

hasEmpty :: GRegex -> Bool
hasEmpty None       = False
hasEmpty Empty      = True
hasEmpty (Chars _)  = False
hasEmpty (r :\/: s) = hasEmpty r || hasEmpty s
hasEmpty (r :/\: s) = hasEmpty r && hasEmpty s
hasEmpty (Not r)    = not (hasEmpty r)
hasEmpty (r :<>: s) = hasEmpty r && hasEmpty s
hasEmpty (Star r)   = True

{-------------------------------------------------------------------------------

We've now come to the main body of the problem set.  In the next two problems,
you'll implement the semantics of regular expressions via the Brzozowski
derivative.  

The derivative of a regular expression is defined as follows.  Recall that a
regular expression generates a set of strings; suppose we have some regular
expression r, and call the set of strings it generates L.  Then, the derivative
*of L* with respect to a string `s` is the set { t | st ∈ L } (that is: the set
of all strings `t` such that the concatenation of strings `st` was in L).  For
example, if L = { "abc", "abd", "bcd" }, then:

* the derivative of L with respect to "a" is { "bc", "bd" };
* the derivative of L with respect to "ab" is {"c", "d" };
* the derivative of L with respect to "b" is {"cd"}; and,
* the derivative of L with respect to "d" is ∅ (the empty set).

This idea extends to regular expressions: the derivative of a regular expression
`r` with respect to string `s` is a new regular expression `r'` that generates
the string t if the original regular expression generated the string st.  For
example, with the regular expression `Chars [a] :<>: Chars [b] :<>: Chars [c]`:

* The derivative with respect to "a" is `Chars [b] :<>: Chars [c]`
* The derivative with respect to "abc" is `Empty`
* The derivative with respect to "d" is `None`.

-------------------------------------------------------------------------------}


--------------------------------------------------------------------------------
-- Problems 7-9: derivc 
--
-- Your first step is to implement `derivc`, which computes the Brozozowski
-- derivative of a regular expression with respect to a *single* character.  For
-- example:
--
-- * derivc 'a' (Chars [a] :<>: Chars [b]) should return Chars [b]
-- * derivc 'a' (Chars [b] :<>: Chars [c]) should return None
--
-- Some cases are "easy":
--
-- * derivc c None should always be None: if your regex didn't recognize any
--   strings beforehand, it still doesn't recognize any strings that start with
--   c.
-- * derivc c Empty should also be None: if your regex only recognized the empty
--   string, it didn't recognize any strings starting with c.
-- * derivc c (Chars cs) depends on whether c is in cs.
--
-- The most interesting cases are for concatenation (:<>:) and Star.  You may
-- find your `hasEmpty` function helpful.

derivc :: Char -> GRegex -> GRegex
derivc _ None       = None
derivc _ Empty      = None
derivc c (Chars cs) 
  | c `elem` cs     = Empty
  | otherwise       = None
derivc c (r :\/: s) = derivc c r :\/: derivc c s
derivc c (r :/\: s) = derivc c r :/\: derivc c s
derivc c (Not r)    = Not (derivc c r)
derivc c (r :<>: s)
  | hasEmpty r      = (derivc c r :<>: s) :\/: derivc c s
  | otherwise       = derivc c r :<>: s
derivc c (Star r)   = derivc c r :<>: Star r

--------------------------------------------------------------------------------
-- Problem 10: deriv
--
-- Finally, you can use your `derivc` function to compute the derivative of a
-- regular expression with respect to an input string.
--
-- Note: You are *not* testing for acceptance yet.  In particular, the
-- derivative of a regular expression `r` with respect to the empty string is
-- always `r`, whether or not `r` accepts the empty string!  The point is that,
-- if r accepts any strings, then it accepts all of those strings prepended with
-- the empty string.

deriv :: String -> GRegex -> GRegex
deriv [] r       = r
deriv (c : cs) r = deriv cs (derivc c r)

--------------------------------------------------------------------------------
-- If you've implemented `deriv` and `hasEmpty` correctly, the following
-- function tests whether a regular expression accepts a given string.

accepts :: GRegex -> String -> Bool
accepts r cs = hasEmpty (deriv cs r)
